From 40809ea8bc84e7311a63be4de9a779806c39e57f Mon Sep 17 00:00:00 2001
From: David Bauer <mail@david-bauer.net>
Date: Fri, 6 Nov 2020 01:34:39 +0100
Subject: [PATCH 1/3] net: dsa: add Atheros AR9344 tag

Add support for the Atheros AR9344 tag used on AR934x / QCA953x /
QCA955x / QCA9561 chips.

The tag is in the same position as the QCA8K tag, however the bitmask is
different. And of course they use the same version ID.

Thus, an additional tag is needed.

Signed-off-by: David Bauer <mail@david-bauer.net>
---
 include/net/dsa.h    |  2 +
 net/dsa/Kconfig      |  6 +++
 net/dsa/Makefile     |  1 +
 net/dsa/tag_ar9344.c | 92 ++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 101 insertions(+)
 create mode 100644 net/dsa/tag_ar9344.c

--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -45,6 +45,7 @@ struct phylink_link_state;
 #define DSA_TAG_PROTO_OCELOT_VALUE		15
 #define DSA_TAG_PROTO_AR9331_VALUE		16
 #define DSA_TAG_PROTO_RTL4_A_VALUE		17
+#define DSA_TAG_PROTO_AR9344_VALUE		18
 
 enum dsa_tag_protocol {
 	DSA_TAG_PROTO_NONE		= DSA_TAG_PROTO_NONE_VALUE,
@@ -65,6 +66,7 @@ enum dsa_tag_protocol {
 	DSA_TAG_PROTO_OCELOT		= DSA_TAG_PROTO_OCELOT_VALUE,
 	DSA_TAG_PROTO_AR9331		= DSA_TAG_PROTO_AR9331_VALUE,
 	DSA_TAG_PROTO_RTL4_A		= DSA_TAG_PROTO_RTL4_A_VALUE,
+	DSA_TAG_PROTO_AR9344		= DSA_TAG_PROTO_AR9344_VALUE,
 };
 
 struct packet_type;
--- a/net/dsa/Kconfig
+++ b/net/dsa/Kconfig
@@ -36,6 +36,12 @@ config NET_DSA_TAG_AR9331
 	  Say Y or M if you want to enable support for tagging frames for
 	  the Atheros AR9331 SoC with built-in switch.
 
+config NET_DSA_TAG_AR9344
+	tristate "Tag driver for Atheros AR934x / QCA95xx SoC with built-in switch"
+	help
+	  Say Y or M if you want to enable support for tagging frames for
+	  the Atheros AR934x / QCA95xx SoC family with built-in switch.
+
 config NET_DSA_TAG_BRCM_COMMON
 	tristate
 	default n
--- a/net/dsa/Makefile
+++ b/net/dsa/Makefile
@@ -6,6 +6,7 @@ dsa_core-y += dsa.o dsa2.o master.o port
 # tagging formats
 obj-$(CONFIG_NET_DSA_TAG_8021Q) += tag_8021q.o
 obj-$(CONFIG_NET_DSA_TAG_AR9331) += tag_ar9331.o
+obj-$(CONFIG_NET_DSA_TAG_AR9344) += tag_ar9344.o
 obj-$(CONFIG_NET_DSA_TAG_BRCM_COMMON) += tag_brcm.o
 obj-$(CONFIG_NET_DSA_TAG_DSA) += tag_dsa.o
 obj-$(CONFIG_NET_DSA_TAG_EDSA) += tag_edsa.o
--- /dev/null
+++ b/net/dsa/tag_ar9344.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 David Bauer <mail@david-bauer.net>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/etherdevice.h>
+
+#include "dsa_priv.h"
+
+#define AR9344_HDR_LEN		2
+#define AR9344_HDR_VERSION	0x2
+
+#define AR9344_HDR_VERSION_MASK		GENMASK(15, 14)
+#define AR9344_HDR_PRIORITY_MASK	GENMASK(13, 12)
+#define AR9344_HDR_ONTROL_MASK		GENMASK(11, 8)
+#define AR9344_HDR_FROM_CPU		BIT(7)
+#define AR9344_HDR_PORT_BIT_MASK	GENMASK(6, 0)
+
+static struct sk_buff *ar9344_tag_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	__be16 *phdr;
+	u16 hdr;
+
+	if (skb_cow_head(skb, AR9344_HDR_LEN) < 0)
+		return NULL;
+
+	skb_push(skb, AR9344_HDR_LEN);
+
+	memmove(skb->data, skb->data + AR9344_HDR_LEN, 2 * ETH_ALEN);
+	phdr = (__be16 *)(skb->data + 2 * ETH_ALEN);
+
+	/* Set the version field, and set destination port information */
+	hdr = FIELD_PREP(AR9344_HDR_VERSION_MASK, AR9344_HDR_VERSION) |
+		AR9344_HDR_FROM_CPU | BIT(dp->index);
+
+	*phdr = htons(hdr);
+
+	return skb;
+}
+
+static struct sk_buff *ar9344_tag_rcv(struct sk_buff *skb, struct net_device *dev,
+				      struct packet_type *pt)
+{
+	u8 ver;
+	u16  hdr;
+	int port;
+	__be16 *phdr;
+
+	if (unlikely(!pskb_may_pull(skb, AR9344_HDR_LEN)))
+		return NULL;
+
+	/* The QCA header is added by the switch between src addr and Ethertype
+	 * At this point, skb->data points to ethertype so header should be
+	 * right before
+	 */
+	phdr = (__be16 *)(skb->data - 2);
+	hdr = ntohs(*phdr);
+
+	/* Make sure the version is correct */
+	ver = FIELD_GET(AR9344_HDR_VERSION_MASK, hdr);
+	if (unlikely(ver != AR9344_HDR_VERSION))
+		return NULL;
+
+	/* Remove QCA tag and recalculate checksum */
+	skb_pull_rcsum(skb, AR9344_HDR_LEN);
+	memmove(skb->data - ETH_HLEN, skb->data - ETH_HLEN - AR9344_HDR_LEN,
+		ETH_HLEN - AR9344_HDR_LEN);
+
+	/* Get source port information */
+	port = (hdr & AR9344_HDR_PORT_BIT_MASK);
+
+	skb->dev = dsa_master_find_slave(dev, 0, port);
+	if (!skb->dev)
+		return NULL;
+
+	return skb;
+}
+
+static const struct dsa_device_ops ar9344_netdev_ops = {
+	.name	= "ar9344",
+	.proto	= DSA_TAG_PROTO_AR9344,
+	.xmit	= ar9344_tag_xmit,
+	.rcv	= ar9344_tag_rcv,
+	.overhead = AR9344_HDR_LEN,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_AR9344);
+
+module_dsa_tag_driver(ar9344_netdev_ops);
